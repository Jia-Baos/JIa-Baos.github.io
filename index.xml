<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jia-Baos</title>
    <link>https://jia-baos.github.io/</link>
    <description>Recent content on Jia-Baos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 31 Jul 2023 09:53:46 +0800</lastBuildDate><atom:link href="https://jia-baos.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>常量指针和指针常量</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 31 Jul 2023 09:53:46 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</guid>
      <description>常量指针：指向常量的指针，将指针的内容作为地址寻址，获取该地址处的变量，该变量被const修饰；
指针常量：指针是常量，当前指针被const修饰，将其内容作为地址寻址，获取该地址处的变量，该变量可以变化。
#include &amp;lt;bits//stdc++.h&amp;gt; int main() { int val1{}; int val2{}; // 常量指针 // 可更改指向，但不可更改原指向的内容 const int *ptr1 = &amp;amp;val1; //*ptr1 = 1; // Error ptr1 = &amp;amp;val2; // 指针常量 // 可更改指向的内容，但不可更改指向 int *const ptr2 = &amp;amp;val1; *ptr2 = 1; //ptr2 = &amp;amp;val2; //Error } </description>
    </item>
    
    <item>
      <title>C&#43;&#43;20管道运算符</title>
      <link>https://jia-baos.github.io/basical-skills/c&#43;&#43;20%E7%AE%A1%E9%81%93%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Sun, 23 Jul 2023 18:56:50 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/c&#43;&#43;20%E7%AE%A1%E9%81%93%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;ranges&amp;gt; int main() { auto const ints = { 0,1,2,3,4,5 }; auto even = [](int i) { return 0 == i % 2; }; auto square = [](int i) { return i * i; }; // 组合视图的“管道”语法： for (int i : ints | std::views::filter(even) | std::views::transform(square)) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; std::endl; // 传统的“函数式”组合语法,filter是筛选，然后再用transform筛选 for (int i : std::views::transform(std::views::filter(ints, even), square)) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; std::endl; auto f = std::views::transform([](int n) { return n *= n; }); auto ret = ints | f;//并没有改变ints，只是返回一个序列 for (auto i : ret) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } } 运算符重载实现管道运算符</description>
    </item>
    
    <item>
      <title>C语言数组</title>
      <link>https://jia-baos.github.io/basical-skills/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 19 Jul 2023 12:43:20 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</guid>
      <description>仅在以下3种情况中，数组不会退化成指针
使用sizeof(a)的时候； 对数组名取地址操作：&amp;amp;a。&amp;amp;a的类型为pointer to array of 6 chars； 使用字符串初始化数组的时候也不会退化。 其它情况都会退化成“指向数组首元素的指针”
数组名做函数参数时，a都会退化成&amp;amp;a[0]指针； 二维数组，char s[10][8]数组的首元素（得理解这个首元素，从一维数组的角度看的）是一维数组s[0]，因此退化成&amp;amp;s[0]指针。 数组定义字符串和指针定义字符串的区别
使用数字定义的字符串只分配字符串所需的空间，数字名没有单独的存储空间；使用指针定义字符串，除了字符串占用的空间，还要为指针变量分配对应的空间。 数组退化成指针为“指针常量”，不可更改，而直接指向字符串的指针可修改。 #include &amp;lt;iostream&amp;gt; int mysize(int arr[] ) { return sizeof(arr); } int main(int argc, char* argv[]) { int arr1[10]{ 0,1,2,3,4,5,6,7,8,9 }; using type1 = decltype(arr1);	// int [10] using type2 = decltype(arr1[0]);	// int &amp;amp; using type3 = decltype(&amp;amp;arr1[0]);	// int * int* ptr1 = arr1; int* ptr2 = &amp;amp;arr1[0]; puts(&amp;#34;----------------&amp;#34;); std::cout &amp;lt;&amp;lt; sizeof(arr1) &amp;lt;&amp;lt; std::endl;	// 40 std::cout &amp;lt;&amp;lt; mysize(arr1) &amp;lt;&amp;lt; std::endl;	// 8 std::cout &amp;lt;&amp;lt; sizeof(ptr1) &amp;lt;&amp;lt; std::endl;	// 8 std::cout &amp;lt;&amp;lt; sizeof(ptr2) &amp;lt;&amp;lt; std::endl;	// 8 puts(&amp;#34;----------------&amp;#34;); std::cout &amp;lt;&amp;lt; *ptr1++ &amp;lt;&amp;lt; std::endl;	// 0 std::cout &amp;lt;&amp;lt; *ptr1 &amp;lt;&amp;lt; std::endl;	// 1 std::cout &amp;lt;&amp;lt; *ptr2++ &amp;lt;&amp;lt; std::endl;	// 0 std::cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; std::endl;	// 1 puts(&amp;#34;----------------&amp;#34;); type1 arr2 = { 1,2,3 };	// for (rsize_t i = 0; i &amp;lt; 10; i++) { std::cout &amp;lt;&amp;lt; arr2[i] &amp;lt;&amp;lt; std::endl; } return 0; } 二维数组</description>
    </item>
    
    <item>
      <title>大小端判断</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%88%A4%E6%96%AD/</link>
      <pubDate>Wed, 19 Jul 2023 11:08:48 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%88%A4%E6%96%AD/</guid>
      <description>大小端判断
大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储期地址；
小端：较高的有效字节存放在较高的存储期地址，较低的有效字节存放在较低的存储期地址。
#include &amp;lt;iostream&amp;gt; union MyUnion { int a; char b; }; int func() { MyUnion union1; union1.a = 1; // 因小端存储，所以 union1.a == union1.b std::cout &amp;lt;&amp;lt; sizeof(union1) &amp;lt;&amp;lt; std::endl; return union1.a == union1.b; } int main(int argc, char* argv[]) { if (func()) { puts(&amp;#34;小端存储&amp;#34;); } else { puts(&amp;#34;大端存储&amp;#34;); } return 0; } </description>
    </item>
    
    <item>
      <title>动态、静态类型</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%8A%A8%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 15 Jul 2023 17:23:05 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%8A%A8%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</guid>
      <description>如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。
#include &amp;lt;iostream&amp;gt; struct Base { virtual ~Base() {} }; struct Derived : Base { }; int main(int argc, char* argv[]) { Derived derived; Base* ptr = &amp;amp;derived; puts(&amp;#34;----------------&amp;#34;); // (*ptr)的静态类型是B // (*ptr)的静态类型是D std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::is_same_v&amp;lt;std::remove_reference_t&amp;lt;decltype(*ptr)&amp;gt;, Base&amp;gt; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; (typeid(*ptr) == typeid(Base)) &amp;lt;&amp;lt; std::endl; // ---------------- // true // false } #include &amp;lt;iostream&amp;gt; #include &amp;lt;typeinfo&amp;gt; #define OUTPUT(f) std::cout &amp;lt;&amp;lt; #f &amp;lt;&amp;lt; &amp;#34;\t: &amp;#34; &amp;lt;&amp;lt; typeid(f).</description>
    </item>
    
    <item>
      <title>形参包解析</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%BD%A2%E5%8F%82%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 15 Jul 2023 16:49:48 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%BD%A2%E5%8F%82%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>形参包的解析可以有两种方式：
递归 折叠表达式 #include &amp;lt;iostream&amp;gt; template&amp;lt;int...args&amp;gt; constexpr int test1 = (args - ...); template&amp;lt;int...args&amp;gt; constexpr int test2 = (... - args); // 递归终止 void print1() {} template &amp;lt;typename T, typename...Types&amp;gt; void print1(const T&amp;amp; firstArg, const Types&amp;amp;...args) { std::cout &amp;lt;&amp;lt; firstArg &amp;lt;&amp;lt; std::endl; // print() first argument print1(args...); // call print() for remaining arguments } // 二元折叠表达式 template&amp;lt;typename...Args&amp;gt; void print2(Args&amp;amp;&amp;amp;...args) { (std::cout &amp;lt;&amp;lt; ... &amp;lt;&amp;lt; args) &amp;lt;&amp;lt; std::endl; } // 一元右折叠表达式+逗号表达式 template&amp;lt;typename.</description>
    </item>
    
    <item>
      <title>异常中new对象</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%BC%82%E5%B8%B8%E4%B8%ADnew%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 15 Jul 2023 16:10:41 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%BC%82%E5%B8%B8%E4%B8%ADnew%E5%AF%B9%E8%B1%A1/</guid>
      <description>MSVC下可通过编译，GCC报错。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;exception&amp;gt; struct MyException : std::exception { MyException(const char* s) : exception(s) { puts(&amp;#34;MyException()...&amp;#34;); } ~MyException() { puts(&amp;#34;~MyException()...&amp;#34;); } }; void f1() try { throw MyException(&amp;#34;MyException...&amp;#34;); } // 与其他临时对象不同，异常对象在初始化 catch 子句形参时被认为是左值， // 所以它可以用左值引用捕获、修改及重抛。 catch (std::exception&amp;amp; e) { std::cerr &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl; } void f2() try { throw new MyException(&amp;#34;new MyException...&amp;#34;); } catch (std::exception* e) { std::cerr &amp;lt;&amp;lt; e-&amp;gt;what() &amp;lt;&amp;lt; std::endl; delete e; } int main(int argc, char* argv[]) { f1(); puts(&amp;#34;----------------&amp;#34;); f2(); } </description>
    </item>
    
    <item>
      <title>伪析构函数</title>
      <link>https://jia-baos.github.io/basical-skills/%E4%BC%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 15 Jul 2023 12:21:10 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E4%BC%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>#include &amp;lt;iostream&amp;gt; template&amp;lt;typename T&amp;gt; concept is_destruct = requires(T t) { t.~T(); }; struct X { }; int main(int argc, char* argv[]) { // 拜伪析构函数调用所赐，所有标量类型都满足可析构 (Destructible) 的要求， // 而数组类型和引用类型则不满足。 std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; is_destruct&amp;lt;X&amp;gt; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; is_destruct&amp;lt;int&amp;gt; &amp;lt;&amp;lt; std::endl; using type = int; type a = 1; a.~type();	// 生存期结束 std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl;	// 生存期外，存储期内 } </description>
    </item>
    
    <item>
      <title>复制消除</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4/</link>
      <pubDate>Sat, 15 Jul 2023 11:14:08 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; struct X { X() { puts(&amp;#34;int&amp;#34;); } X(const int &amp;amp;) { puts(&amp;#34;const int&amp;amp;&amp;#34;); } X(int &amp;amp;&amp;amp;) { puts(&amp;#34;int&amp;amp;&amp;amp;&amp;#34;); } }; X f() { return X(); } int main(int argc, char *argv[]) { X x1 = 1; // int&amp;amp;&amp;amp; puts(&amp;#34;--------------&amp;#34;); X x2 = f(); // int } [1]复制消除</description>
    </item>
    
    <item>
      <title>运算符重载</title>
      <link>https://jia-baos.github.io/basical-skills/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 15 Jul 2023 10:39:36 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; struct X { int val_; X(int val) : val_{val} {} bool operator==(const X &amp;amp;x) const { return x.val_ == this-&amp;gt;val_; } }; struct Y { int val_; Y(int val) : val_{val} {} // 运算符重载推荐使用非成员函数 friend bool operator==(const Y &amp;amp;a, const Y &amp;amp;b) { return a.val_ == b.val_; } }; int main(int argc, char *argv[]) { X x1{1}; X x2{1}; Y y1{1}; Y y2{1}; x1 == x2; x2 == x1; x1 == 1; //1 == x1; // 在C++20可以保证被编译 y1 == y2; y2 == y1; y1 == 1; 1 == y1; } </description>
    </item>
    
    <item>
      <title>对象存储可变参数</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 15 Jul 2023 10:25:23 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; // std::invocable 检查类型能否以给定的实参类型调用 template&amp;lt;typename F, typename...Args&amp;gt; requires std::invocable&amp;lt;F, Args...&amp;gt; struct Input { using R = std::invoke_result_t&amp;lt;F, Args...&amp;gt;; F f_; // 可调用对象 std::tuple&amp;lt;Args...&amp;gt; value_; // 存储可变参数 Input(F f, Args...args) : f_(f), value_(args...) {} constexpr R operator()() const noexcept { // std::apply 推导以一组实参调用一个可调用对象的结果类型 return std::apply(f_, value_); } }; int main(int argc, char *argv[]) { // 传入可调用对象和形参包 Input input([](int a, float b) { std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl; }, 1, 2.</description>
    </item>
    
    <item>
      <title>函数声明</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 15 Jul 2023 10:05:33 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; void func(int n) { std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } using type = decltype(func); type F; // 函数声明 int main() { F(1); } void F(int) { std::cout &amp;lt;&amp;lt; &amp;#34;Defination of Function&amp;#34; &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>传递函数模板</title>
      <link>https://jia-baos.github.io/basical-skills/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sat, 15 Jul 2023 09:49:14 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; #define BY_NAME(F) [](auto&amp;amp;&amp;amp;...args){return F(args...);} template&amp;lt;typename F, typename...Args&amp;gt; auto foo(F f, Args &amp;amp;&amp;amp;...args) { return f(std::forward&amp;lt;Args&amp;gt;(args)...); } int main() { const auto val1 = foo([](auto &amp;amp;&amp;amp;...args) { return std::min(args...); }, 1, 2); std::cout &amp;lt;&amp;lt; val1 &amp;lt;&amp;lt; std::endl; const auto val2 = foo(BY_NAME(std::min), 1, 2); std::cout &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>重载、重写、覆盖</title>
      <link>https://jia-baos.github.io/basical-skills/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96/</link>
      <pubDate>Fri, 14 Jul 2023 19:37:43 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96/</guid>
      <description>#include &amp;lt;iostream&amp;gt; class A { public: virtual void vfunc1() { puts(&amp;#34;A::vfunc1&amp;#34;); } virtual void vfunc2() { puts(&amp;#34;A::vfunc2&amp;#34;); } void func1() { puts(&amp;#34;A::func1&amp;#34;); } void func2() { puts(&amp;#34;A::func2&amp;#34;); } virtual void vfunc2(int val) { puts(&amp;#34;A::vfunc2 overload&amp;#34;); } void func2(int val) { puts(&amp;#34;A::func2 overload&amp;#34;); } private: int m_data1; int m_data2; }; class B :public A { public: virtual void vfunc1() { puts(&amp;#34;B::vfunc1&amp;#34;); } void func1() { puts(&amp;#34;B::func1&amp;#34;); } private: int m_data3; }; class C :public B { public: virtual void vfunc2() { puts(&amp;#34;C::vfunc2&amp;#34;); } void func2() { puts(&amp;#34;C::func2&amp;#34;); } private: int m_data1; int m_data4; }; int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; _MSVC_LANG &amp;lt;&amp;lt; std::endl; A a; B b; C c; puts(&amp;#34;-----------------&amp;#34;); a.</description>
    </item>
    
    <item>
      <title>STL仿函数</title>
      <link>https://jia-baos.github.io/basical-skills/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 12 Jul 2023 20:44:46 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</guid>
      <description>函数对象（也称 函子）是实现 operator() 的任何类型。 此运算符被称为 调用运算符 （有时称为 应用程序运算符）。 C++ 标准库主要使用函数对象作为容器和算法内的排序条件。
相对于直接函数调用，函数对象有两个优势。 第一个是函数对象可包含状态。 第二个是函数对象是一个类型，因此可用作模板参数。
#include &amp;lt;bits/stdc++.h&amp;gt; class Functor { public: int operator()(int a, int b) { return a &amp;lt; b; } }; int main() { std::cout &amp;lt;&amp;lt; __cplusplus &amp;lt;&amp;lt; std::endl; Functor f; int a = 5; int b = 7; std::cout &amp;lt;&amp;lt; f(a, b) &amp;lt;&amp;lt; std::endl; // 1 return 0; } 函数指针。
不足：无法利用函数指针指向模板函数。
#include &amp;lt;iostream&amp;gt; int cal(int val) { return val * val; } int main(int argc, char* argv[]) { // 函数指针定义方式 // 函数返回值类型 (* 指针变量名) (函数参数列表) int (*ptr_func)(int) = nullptr; ptr_func = cal; int val1 = cal(5); // 通过函数调用 int val2 = (*ptr_func)(5); // 通过指针调用，推荐 int val3 = ptr_func(5); // 不推荐 std::cout &amp;lt;&amp;lt; &amp;#34;val1 &amp;#34; &amp;lt;&amp;lt; val1 &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;val2 &amp;#34; &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;val3 &amp;#34; &amp;lt;&amp;lt; val3 &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>模块</title>
      <link>https://jia-baos.github.io/basical-skills/%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 12 Jul 2023 17:16:44 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E6%A8%A1%E5%9D%97/</guid>
      <description>// Module.ixx module; import &amp;lt;concepts&amp;gt;; export module test; namespace JB { export template&amp;lt;typename T&amp;gt; requires std::is_integral_v&amp;lt;T&amp;gt; T add(const T&amp;amp; t) { return t + 1; } } // main.cpp #include &amp;lt;iostream&amp;gt; import test; int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; JB::add(1) &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>完美转发</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Wed, 12 Jul 2023 08:23:07 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>std::forward被称为完美转发，它的作用是保持原来的值属性不变。
#include &amp;lt;bits/stdc++.h&amp;gt; template&amp;lt;typename T&amp;gt; void print(T &amp;amp; t){ std::cout &amp;lt;&amp;lt; &amp;#34;left value&amp;#34; &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T&amp;gt; void print(T &amp;amp;&amp;amp; t){ std::cout &amp;lt;&amp;lt; &amp;#34;right value&amp;#34; &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T&amp;gt; void testForward(T &amp;amp;&amp;amp; v){ print(v); print(std::forward&amp;lt;T&amp;gt;(v)); print(std::move(v)); } int main() { std::cout &amp;lt;&amp;lt; __cplusplus &amp;lt;&amp;lt; std::endl; testForward(1); /* * left value * right value * right value */ int x = 1; testForward(x); /* * left value * left value * right value */ return 0; } #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>概念、约束</title>
      <link>https://jia-baos.github.io/basical-skills/%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Tue, 11 Jul 2023 22:42:52 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;concepts&amp;gt; template&amp;lt;typename T&amp;gt; concept is_integral = std::is_integral_v&amp;lt;T&amp;gt;; // requires 子句，不是 requires 表达式 template&amp;lt;typename T&amp;gt; requires is_integral&amp;lt;T&amp;gt; T add0(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;用require关键字定义一个概念或约束，requires子句&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } // 临时约束，注意关键字用了两次 template&amp;lt;typename T&amp;gt; requires requires (T t) { std::is_integral_v&amp;lt;T&amp;gt;; } T add1(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;用require关键字定义一个概念或约束，requires表达式，临时约束&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } template&amp;lt;typename T&amp;gt; T add2(const T&amp;amp; t) requires is_integral&amp;lt;T&amp;gt; { std::cout &amp;lt;&amp;lt; &amp;#34;在函数签名中使用require关键字&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } template&amp;lt;is_integral T&amp;gt; T add3(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;在模板声明中使用概念&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } auto add4(const is_integral auto&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;在参数列表中使用概念&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } // 经由返回类型启用 template&amp;lt;typename T&amp;gt; typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type add5(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由返回类型启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } // 经由非类型模板形参启用 template&amp;lt;typename T, std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type = 0&amp;gt; T add6(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由非类型模板形参启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } // 经由类型模板形参启用 template&amp;lt;typename T, typename = typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type&amp;gt; T add7(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由类型模板形参启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; add0(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add1(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add2(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add3(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add4(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add5(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add6(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add7(1) &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>Traits特性</title>
      <link>https://jia-baos.github.io/basical-skills/traits%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 11 Jul 2023 15:15:37 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/traits%E7%89%B9%E6%80%A7/</guid>
      <description>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”. - Bjarne Stroustrup
模板的全特化、偏特化。
#include &amp;lt;bits/stdc++.h&amp;gt; // 模板一般化设计 /* * 模板全特化和偏特化设计版本存在时， * 优点调用 */ template &amp;lt;typename T&amp;gt; struct MyPrint { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板一般化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 模板全特化设计 template &amp;lt;&amp;gt; struct MyPrint&amp;lt;float&amp;gt; { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板全特化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 模板偏特化设计 /* *模板特化时，可以只指定一部分而非所有模板参数， *或者是参数的一部分而非全部特性，这叫做模板的偏特化。 *一个类模板的偏特化本身是一个模板， *使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。 */ template &amp;lt;typename T&amp;gt; struct MyPrint&amp;lt;T *&amp;gt; { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板偏特化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main(int argc, char *argv[]) { MyPrint&amp;lt;int&amp;gt; a; MyPrint&amp;lt;float&amp;gt; b; MyPrint&amp;lt;float *&amp;gt; c; a.</description>
    </item>
    
    <item>
      <title>卖柑者言</title>
      <link>https://jia-baos.github.io/recent-works/%E5%8D%96%E6%9F%91%E8%80%85%E8%A8%80/</link>
      <pubDate>Mon, 10 Jul 2023 15:55:57 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/recent-works/%E5%8D%96%E6%9F%91%E8%80%85%E8%A8%80/</guid>
      <description>——明代、刘基
杭有卖果者，善藏柑，涉寒暑不溃。出之烨然，玉质而金色。置于市，贾十倍，人争鬻之。予贸得其一，剖之，如有烟扑口鼻，视其中，则干若败絮。予怪而问之曰：“若所市于人者，将以实笾豆，奉祭祀，供宾客乎？将炫外以惑愚瞽也？甚矣哉，为欺也！”
卖者笑曰：“吾业是有年矣，吾赖是以食吾躯。吾售之，人取之，未尝有言，而独不足子所乎？世之为欺者不寡矣，而独我也乎？吾子未之思也。今夫佩虎符、坐皋比者，洸洸乎干城之具也，果能授孙、吴之略耶？ 峨大冠、 拖长绅者，昂昂乎庙堂之器也，果能建伊、皋之业耶？盗起而不知御，民困而不知救，吏奸而不知禁，法斁而不知理，坐糜廪粟而不知耻。观其坐高堂，骑大马，醉醇醴而饫肥鲜者，孰不巍巍乎可畏，赫赫乎可象也？又何往而不金玉其外，败絮其中也哉？今子是之不察，而以察吾柑！”
予默然无以应。退而思其言，类东方生滑稽之流。岂其愤世疾邪者耶？而托于柑以讽耶？</description>
    </item>
    
    <item>
      <title>左值、右值</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</link>
      <pubDate>Mon, 10 Jul 2023 10:46:51 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</guid>
      <description>值类别 每个 C++ 表达式（带有操作数的操作符、字面量、变量名等）可按照两种独立的特性加以辨别：类型和值类别 (value category)。每个表达式都具有某种非引用类型，且每个表达式只属于三种基本值类别中的一种：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)。
泛左值 (glvalue)（“泛化 (generalized)”的左值）是一个表达式，其值可确定某个对象或函数的标识； 纯右值 (prvalue)（“纯 (pure)”的右值）是求值符合下列之一的表达式： 计算某个运算符的操作数的值（这种纯右值没有结果对象） 初始化某个对象（称这种纯右值有一个结果对象）。结果对象可以是变量，由 new 表达式创建的对象，由临时量实质化创建的临时对象，或者前述三类对象的成员。注意非 void 的弃值表达式有结果对象（即被实质化的临时量）。并且在作为 decltype 的操作数以外的情况下，每个类类型或数组类型的纯右值都有结果对象； 亡值 (xvalue)（“将亡 (expiring)”的值）是代表它的资源能够被重新使用的对象或位域的泛左值； 左值 (lvalue)（如此称呼的历史原因是，左值可以在赋值表达式的左边出现）是非亡值的泛左值； 右值 (rvalue)（如此称呼的历史原因是，右值可以在赋值表达式的右边出现）是纯右值或者亡值。 基本类别 左值 下列表达式是左值表达式：
变量、函数、模板形参对象 (C++20 起)或数据成员的名字，不论类型，例如 std::cin 或 std::endl。即使变量的类型是右值引用，由它的名字构成的表达式仍是左值表达式； 返回类型是左值引用的函数调用或重载运算符表达式，例如 std::getline(std::cin, str)、std::cout &amp;lt;&amp;lt; 1、str1 = str2 或 ++it； a = b，a += b，a %= b，以及所有其他内建的赋值及复合赋值表达式； ++a 和 --a，内建的前置自增与前置自减表达式； *p，内建的间接寻址表达式； a[n] 和 n[a]，内建的下标表达式，当 a[n] 中的一个操作数是数组左值时 (C++11 起)； a.m，对象成员表达式，除了 m 是成员枚举项或非静态成员函数，或者 a 是右值而 m 是对象类型的非静态数据成员的情况； p-&amp;gt;m，内建的指针成员表达式，除了 m 是成员枚举项或非静态成员函数的情况； a.</description>
    </item>
    
    <item>
      <title>Biography</title>
      <link>https://jia-baos.github.io/biography/biography/</link>
      <pubDate>Thu, 20 Apr 2023 17:04:11 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/biography/biography/</guid>
      <description>Notes: Here is a link to my Github homepage, Jia-Baos.
I am pursuing my master’s degree in Shandong University of Science and Technology. My main focus is computer vision and their applications in industry, besides, i am pleased to embrace new technologies and amazing ideas.</description>
    </item>
    
    <item>
      <title>Demons 算法</title>
      <link>https://jia-baos.github.io/recent-works/demons%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 20 Apr 2023 17:04:11 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/recent-works/demons%E7%AE%97%E6%B3%95/</guid>
      <description>Notes: Here is a link to my Github homepage, Jia-Baos.
This is my personal implementation of the Demons algorithm, which can be used to recover non-rigid deformation between images, enjoy yourself&amp;hellip;
Fixed Moved Warpped Res </description>
    </item>
    
    <item>
      <title>光流估计</title>
      <link>https://jia-baos.github.io/recent-works/%E5%85%89%E6%B5%81%E4%BC%B0%E8%AE%A1/</link>
      <pubDate>Thu, 20 Apr 2023 17:04:11 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/recent-works/%E5%85%89%E6%B5%81%E4%BC%B0%E8%AE%A1/</guid>
      <description>Notes: Here is a link to my Github homepage, Jia-Baos.
There are many excellent works about optical flow estimation, which is closely related to our research.
Matching methods: AKAZE, DeepMatching, CPM.
Interpolation methods: LDOF, DeepFlow, EpicFlow, RicFlow.
Source code of our work will be soon available online at ACPM&amp;hellip;</description>
    </item>
    
    <item>
      <title>Basical Skills</title>
      <link>https://jia-baos.github.io/biography/basicalskills/</link>
      <pubDate>Wed, 05 Apr 2023 12:08:11 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/biography/basicalskills/</guid>
      <description>Notes: Here is a link to my Github homepage, Jia-Baos.
C++ is the programming language i use most, python and shell are often used for scripting, furthermore, cmake and mingw wil be used for compiling across platforms.
Opencv is the 3rd party library i use most, besides, i&amp;rsquo;m also trying more 3rd party libraries such as: Blas, MKL, etc.</description>
    </item>
    
  </channel>
</rss>
