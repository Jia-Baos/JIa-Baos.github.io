<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on Jia-Baos</title>
    <link>https://jia-baos.github.io/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on Jia-Baos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language><atom:link href="https://jia-baos.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>复制消除</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4/</link>
      <pubDate>Sat, 15 Jul 2023 11:14:08 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; struct X { X() { puts(&amp;#34;int&amp;#34;); } X(const int &amp;amp;) { puts(&amp;#34;const int&amp;amp;&amp;#34;); } X(int &amp;amp;&amp;amp;) { puts(&amp;#34;int&amp;amp;&amp;amp;&amp;#34;); } }; X f() { return X(); } int main(int argc, char *argv[]) { X x1 = 1; // int&amp;amp;&amp;amp; puts(&amp;#34;--------------&amp;#34;); X x2 = f(); // int } [1]复制消除</description>
    </item>
    
    <item>
      <title>运算符重载</title>
      <link>https://jia-baos.github.io/basical-skills/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 15 Jul 2023 10:39:36 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; struct X { int val_; X(int val) : val_{val} {} bool operator==(const X &amp;amp;x) const { return x.val_ == this-&amp;gt;val_; } }; struct Y { int val_; Y(int val) : val_{val} {} // 运算符重载推荐使用非成员函数 friend bool operator==(const Y &amp;amp;a, const Y &amp;amp;b) { return a.val_ == b.val_; } }; int main(int argc, char *argv[]) { X x1{1}; X x2{1}; Y y1{1}; Y y2{1}; x1 == x2; x2 == x1; x1 == 1; //1 == x1; // 在C++20可以保证被编译 y1 == y2; y2 == y1; y1 == 1; 1 == y1; } </description>
    </item>
    
    <item>
      <title>对象存储可变参数</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 15 Jul 2023 10:25:23 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; // std::invocable 检查类型能否以给定的实参类型调用 template&amp;lt;typename F, typename...Args&amp;gt; requires std::invocable&amp;lt;F, Args...&amp;gt; struct Input { using R = std::invoke_result_t&amp;lt;F, Args...&amp;gt;; F f_; // 可调用对象 std::tuple&amp;lt;Args...&amp;gt; value_; // 存储可变参数 Input(F f, Args...args) : f_(f), value_(args...) {} constexpr R operator()() const noexcept { // std::apply 推导以一组实参调用一个可调用对象的结果类型 return std::apply(f_, value_); } }; int main(int argc, char *argv[]) { // 传入可调用对象和形参包 Input input([](int a, float b) { std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl; }, 1, 2.</description>
    </item>
    
    <item>
      <title>函数声明</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 15 Jul 2023 10:05:33 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; void func(int n) { std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } using type = decltype(func); type F; // 函数声明 int main() { F(1); } void F(int) { std::cout &amp;lt;&amp;lt; &amp;#34;Defination of Function&amp;#34; &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>传递函数模板</title>
      <link>https://jia-baos.github.io/basical-skills/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sat, 15 Jul 2023 09:49:14 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; #define BY_NAME(F) [](auto&amp;amp;&amp;amp;...args){return F(args...);} template&amp;lt;typename F, typename...Args&amp;gt; auto foo(F f, Args &amp;amp;&amp;amp;...args) { return f(std::forward&amp;lt;Args&amp;gt;(args)...); } int main() { const auto val1 = foo([](auto &amp;amp;&amp;amp;...args) { return std::min(args...); }, 1, 2); std::cout &amp;lt;&amp;lt; val1 &amp;lt;&amp;lt; std::endl; const auto val2 = foo(BY_NAME(std::min), 1, 2); std::cout &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>重载、重写、覆盖</title>
      <link>https://jia-baos.github.io/basical-skills/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96/</link>
      <pubDate>Fri, 14 Jul 2023 19:37:43 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96/</guid>
      <description>#include &amp;lt;iostream&amp;gt; class A { public: virtual void vfunc1() { puts(&amp;#34;A::vfunc1&amp;#34;); } virtual void vfunc2() { puts(&amp;#34;A::vfunc2&amp;#34;); } void func1() { puts(&amp;#34;A::func1&amp;#34;); } void func2() { puts(&amp;#34;A::func2&amp;#34;); } virtual void vfunc2(int val) { puts(&amp;#34;A::vfunc2 overload&amp;#34;); } void func2(int val) { puts(&amp;#34;A::func2 overload&amp;#34;); } private: int m_data1; int m_data2; }; class B :public A { public: virtual void vfunc1() { puts(&amp;#34;B::vfunc1&amp;#34;); } void func1() { puts(&amp;#34;B::func1&amp;#34;); } private: int m_data3; }; class C :public B { public: virtual void vfunc2() { puts(&amp;#34;C::vfunc2&amp;#34;); } void func2() { puts(&amp;#34;C::func2&amp;#34;); } private: int m_data1; int m_data4; }; int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; _MSVC_LANG &amp;lt;&amp;lt; std::endl; A a; B b; C c; puts(&amp;#34;-----------------&amp;#34;); a.</description>
    </item>
    
    <item>
      <title>STL仿函数</title>
      <link>https://jia-baos.github.io/basical-skills/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 12 Jul 2023 20:44:46 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</guid>
      <description>函数对象（也称 函子）是实现 operator() 的任何类型。 此运算符被称为 调用运算符 （有时称为 应用程序运算符）。 C++ 标准库主要使用函数对象作为容器和算法内的排序条件。
相对于直接函数调用，函数对象有两个优势。 第一个是函数对象可包含状态。 第二个是函数对象是一个类型，因此可用作模板参数。
#include &amp;lt;bits/stdc++.h&amp;gt; class Functor { public: int operator()(int a, int b) { return a &amp;lt; b; } }; int main() { std::cout &amp;lt;&amp;lt; __cplusplus &amp;lt;&amp;lt; std::endl; Functor f; int a = 5; int b = 7; std::cout &amp;lt;&amp;lt; f(a, b) &amp;lt;&amp;lt; std::endl; // 1 return 0; } </description>
    </item>
    
    <item>
      <title>模块</title>
      <link>https://jia-baos.github.io/basical-skills/%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 12 Jul 2023 17:16:44 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E6%A8%A1%E5%9D%97/</guid>
      <description>// Module.ixx module; import &amp;lt;concepts&amp;gt;; export module test; namespace JB { export template&amp;lt;typename T&amp;gt; requires std::is_integral_v&amp;lt;T&amp;gt; T add(const T&amp;amp; t) { return t + 1; } } // main.cpp #include &amp;lt;iostream&amp;gt; import test; int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; JB::add(1) &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>完美转发</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Wed, 12 Jul 2023 08:23:07 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>std::forward被称为完美转发，它的作用是保持原来的值属性不变。
#include &amp;lt;bits/stdc++.h&amp;gt; template&amp;lt;typename T&amp;gt; void print(T &amp;amp; t){ std::cout &amp;lt;&amp;lt; &amp;#34;left value&amp;#34; &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T&amp;gt; void print(T &amp;amp;&amp;amp; t){ std::cout &amp;lt;&amp;lt; &amp;#34;right value&amp;#34; &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T&amp;gt; void testForward(T &amp;amp;&amp;amp; v){ print(v); print(std::forward&amp;lt;T&amp;gt;(v)); print(std::move(v)); } int main() { std::cout &amp;lt;&amp;lt; __cplusplus &amp;lt;&amp;lt; std::endl; testForward(1); /* * left value * right value * right value */ int x = 1; testForward(x); /* * left value * left value * right value */ return 0; } #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>概念、约束</title>
      <link>https://jia-baos.github.io/basical-skills/%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Tue, 11 Jul 2023 22:42:52 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;concepts&amp;gt; template&amp;lt;typename T&amp;gt; concept is_integral = std::is_integral_v&amp;lt;T&amp;gt;; template&amp;lt;typename T&amp;gt; requires is_integral&amp;lt;T&amp;gt; T add1(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;用require关键字定义一个概念或约束&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } template&amp;lt;typename T&amp;gt; T add2(const T&amp;amp; t) requires is_integral&amp;lt;T&amp;gt; { std::cout &amp;lt;&amp;lt; &amp;#34;在函数签名中使用require关键字&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } template&amp;lt;is_integral T&amp;gt; T add3(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;在模板声明中使用概念&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } auto add4(const is_integral auto&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;在参数列表中使用概念&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } // 经由返回类型启用 template&amp;lt;typename T&amp;gt; typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type add5(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由返回类型启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } // 经由非类型模板形参启用 template&amp;lt;typename T, std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type = 0&amp;gt; T add6(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由非类型模板形参启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } // 经由类型模板形参启用 template&amp;lt;typename T, typename = typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type&amp;gt; T add7(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由类型模板形参启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; add1(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add2(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add3(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add4(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add5(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add6(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add7(1) &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>Traits特性</title>
      <link>https://jia-baos.github.io/basical-skills/traits%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 11 Jul 2023 15:15:37 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/traits%E7%89%B9%E6%80%A7/</guid>
      <description>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”. - Bjarne Stroustrup
模板的全特化、偏特化
#include &amp;lt;bits/stdc++.h&amp;gt; // 模板一般化设计 /* * 模板全特化和偏特化设计版本存在时， * 优点调用 */ template &amp;lt;typename T&amp;gt; struct MyPrint { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板一般化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 模板全特化设计 template &amp;lt;&amp;gt; struct MyPrint&amp;lt;float&amp;gt; { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板全特化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 模板偏特化设计 /* *模板特化时，可以只指定一部分而非所有模板参数， *或者是参数的一部分而非全部特性，这叫做模板的偏特化。 *一个类模板的偏特化本身是一个模板， *使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。 */ template &amp;lt;typename T&amp;gt; struct MyPrint&amp;lt;T *&amp;gt; { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板偏特化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main(int argc, char *argv[]) { MyPrint&amp;lt;int&amp;gt; a; MyPrint&amp;lt;float&amp;gt; b; MyPrint&amp;lt;float *&amp;gt; c; a.</description>
    </item>
    
    <item>
      <title>左值、右值</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</link>
      <pubDate>Mon, 10 Jul 2023 10:46:51 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</guid>
      <description>值类别 每个 C++ 表达式（带有操作数的操作符、字面量、变量名等）可按照两种独立的特性加以辨别：类型和值类别 (value category)。每个表达式都具有某种非引用类型，且每个表达式只属于三种基本值类别中的一种：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)。
泛左值 (glvalue)（“泛化 (generalized)”的左值）是一个表达式，其值可确定某个对象或函数的标识； 纯右值 (prvalue)（“纯 (pure)”的右值）是求值符合下列之一的表达式： 计算某个运算符的操作数的值（这种纯右值没有结果对象） 初始化某个对象（称这种纯右值有一个结果对象）。结果对象可以是变量，由 new 表达式创建的对象，由临时量实质化创建的临时对象，或者前述三类对象的成员。注意非 void 的弃值表达式有结果对象（即被实质化的临时量）。并且在作为 decltype 的操作数以外的情况下，每个类类型或数组类型的纯右值都有结果对象； 亡值 (xvalue)（“将亡 (expiring)”的值）是代表它的资源能够被重新使用的对象或位域的泛左值； 左值 (lvalue)（如此称呼的历史原因是，左值可以在赋值表达式的左边出现）是非亡值的泛左值； 右值 (rvalue)（如此称呼的历史原因是，右值可以在赋值表达式的右边出现）是纯右值或者亡值。 基本类别 左值 下列表达式是左值表达式：
变量、函数、模板形参对象 (C++20 起)或数据成员的名字，不论类型，例如 std::cin 或 std::endl。即使变量的类型是右值引用，由它的名字构成的表达式仍是左值表达式； 返回类型是左值引用的函数调用或重载运算符表达式，例如 std::getline(std::cin, str)、std::cout &amp;lt;&amp;lt; 1、str1 = str2 或 ++it； a = b，a += b，a %= b，以及所有其他内建的赋值及复合赋值表达式； ++a 和 --a，内建的前置自增与前置自减表达式； *p，内建的间接寻址表达式； a[n] 和 n[a]，内建的下标表达式，当 a[n] 中的一个操作数是数组左值时 (C++11 起)； a.m，对象成员表达式，除了 m 是成员枚举项或非静态成员函数，或者 a 是右值而 m 是对象类型的非静态数据成员的情况； p-&amp;gt;m，内建的指针成员表达式，除了 m 是成员枚举项或非静态成员函数的情况； a.</description>
    </item>
    
  </channel>
</rss>
