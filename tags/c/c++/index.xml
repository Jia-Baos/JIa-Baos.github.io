<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on Jia-Baos</title>
    <link>https://jia-baos.github.io/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on Jia-Baos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language><atom:link href="https://jia-baos.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>new和operator new</title>
      <link>https://jia-baos.github.io/basical-skills/new%E5%92%8Coperator-new/</link>
      <pubDate>Mon, 31 Jul 2023 15:24:37 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/new%E5%92%8Coperator-new/</guid>
      <description>new和operator new new：指我们在C++里通常用到的运算符，比如A* a = new A; 对于new来说，有new和::new之分，前者位于std命名空间； operator new：指对new的重载形式，它是一个函数，并不是运算符。 对于operator new来说，分为全局重载和类重载，全局重载是void* ::operator new(size_t size)，在类中重载形式 void* A::operator new(size_t size)。事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个void*指针。而构造函数的调用(如果需要)是在new运算符中完成的。 new和operator new的关系 对于：
A* a = new A(); 其可以分为两步： 1.分配内存，2.调用A()构造对象。
事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，如果没有重载，就调用::operator new(size_t )，全局new操作符由C++默认提供。 因此前面的两步也就是：1.调用operator new 2.调用构造函数。
new ：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。new 操作符的执行过程：
调用operator new分配内存 ； 调用构造函数生成类对象； 返回相应指针。 operator new：要实现不同的内存分配行为，应该重载operator new，而不是new; operator new就像operator + 一样，是可以重载的。同理，operator new[]、operator delete、operator delete[]也是可以重载的。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理</title>
      <link>https://jia-baos.github.io/basical-skills/c&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 31 Jul 2023 14:40:10 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/c&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>自由存储区和堆 由new分配/delete释放的内存开辟于自由存储区，由malloc分配/free释放的内存开辟于堆。 内存泄漏的场景 malloc和free未成对出现；new/new[]和delete/delete[]未成对出现，在构造函数中动态分配内存，但未在析构函数中正确释放内存； 未定义拷贝构造函数或赋值运算符重载，从而造成一块内存被多次释放； 未将基类的析构函数定义为虚函数。 如何让对象只在堆（栈）上分配空间 在C++中，类的对象建立分为两种：
静态建立，如A a； 动态建立，如A* ptr=new A； 这两种方式是有区别的。 1、静态建立类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。 2、动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间，这种方法，间接调用类的构造函数。
只在堆上分配空间 容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operator new()函数只用于分配内存，无法提供构造功能。因此，这种方法不可以。
当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。
class A { public: A() {} void destory() { delete this; } private: ~A() {} }; 析构函数设置为私有的问题：
无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。
类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。
class A { protected: A() {} ~A() {} public: static A* create() { return new A(); } void destory() { delete this; } }; 只在栈上分配空间 只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，将operator new()设为私有即可禁止对象被new在堆上。</description>
    </item>
    
    <item>
      <title>常量指针和指针常量</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 31 Jul 2023 09:53:46 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</guid>
      <description>常量指针：指向常量的指针，将指针的内容作为地址寻址，获取该地址处的变量，该变量被const修饰；
指针常量：指针是常量，当前指针被const修饰，将其内容作为地址寻址，获取该地址处的变量，该变量可以变化。
#include &amp;lt;bits//stdc++.h&amp;gt; int main() { int val1{}; int val2{}; // 常量指针 // 可更改指向，但不可更改原指向的内容 const int *ptr1 = &amp;amp;val1; //*ptr1 = 1; // Error ptr1 = &amp;amp;val2; // 指针常量 // 可更改指向的内容，但不可更改指向 int *const ptr2 = &amp;amp;val1; *ptr2 = 1; //ptr2 = &amp;amp;val2; //Error } </description>
    </item>
    
    <item>
      <title>C&#43;&#43;20管道运算符</title>
      <link>https://jia-baos.github.io/basical-skills/c&#43;&#43;20%E7%AE%A1%E9%81%93%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Sun, 23 Jul 2023 18:56:50 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/c&#43;&#43;20%E7%AE%A1%E9%81%93%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;ranges&amp;gt; int main() { auto const ints = { 0,1,2,3,4,5 }; auto even = [](int i) { return 0 == i % 2; }; auto square = [](int i) { return i * i; }; // 组合视图的“管道”语法： for (int i : ints | std::views::filter(even) | std::views::transform(square)) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; std::endl; // 传统的“函数式”组合语法,filter是筛选，然后再用transform筛选 for (int i : std::views::transform(std::views::filter(ints, even), square)) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; std::endl; auto f = std::views::transform([](int n) { return n *= n; }); auto ret = ints | f;//并没有改变ints，只是返回一个序列 for (auto i : ret) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } } 运算符重载实现管道运算符</description>
    </item>
    
    <item>
      <title>C语言数组</title>
      <link>https://jia-baos.github.io/basical-skills/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 19 Jul 2023 12:43:20 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</guid>
      <description>仅在以下3种情况中，数组不会退化成指针
使用sizeof(a)的时候； 对数组名取地址操作：&amp;amp;a。&amp;amp;a的类型为pointer to array of 6 chars； 使用字符串初始化数组的时候也不会退化。 其它情况都会退化成“指向数组首元素的指针”
数组名做函数参数时，a都会退化成&amp;amp;a[0]指针； 二维数组，char s[10][8]数组的首元素（得理解这个首元素，从一维数组的角度看的）是一维数组s[0]，因此退化成&amp;amp;s[0]指针。 数组定义字符串和指针定义字符串的区别
使用数字定义的字符串只分配字符串所需的空间，数字名没有单独的存储空间；使用指针定义字符串，除了字符串占用的空间，还要为指针变量分配对应的空间。 数组退化成指针为“指针常量”，不可更改，而直接指向字符串的指针可修改。 #include &amp;lt;iostream&amp;gt; int mysize(int arr[] ) { return sizeof(arr); } int main(int argc, char* argv[]) { int arr1[10]{ 0,1,2,3,4,5,6,7,8,9 }; using type1 = decltype(arr1);	// int [10] using type2 = decltype(arr1[0]);	// int &amp;amp; using type3 = decltype(&amp;amp;arr1[0]);	// int * int* ptr1 = arr1; int* ptr2 = &amp;amp;arr1[0]; puts(&amp;#34;----------------&amp;#34;); std::cout &amp;lt;&amp;lt; sizeof(arr1) &amp;lt;&amp;lt; std::endl;	// 40 std::cout &amp;lt;&amp;lt; mysize(arr1) &amp;lt;&amp;lt; std::endl;	// 8 std::cout &amp;lt;&amp;lt; sizeof(ptr1) &amp;lt;&amp;lt; std::endl;	// 8 std::cout &amp;lt;&amp;lt; sizeof(ptr2) &amp;lt;&amp;lt; std::endl;	// 8 puts(&amp;#34;----------------&amp;#34;); std::cout &amp;lt;&amp;lt; *ptr1++ &amp;lt;&amp;lt; std::endl;	// 0 std::cout &amp;lt;&amp;lt; *ptr1 &amp;lt;&amp;lt; std::endl;	// 1 std::cout &amp;lt;&amp;lt; *ptr2++ &amp;lt;&amp;lt; std::endl;	// 0 std::cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; std::endl;	// 1 puts(&amp;#34;----------------&amp;#34;); type1 arr2 = { 1,2,3 };	// for (rsize_t i = 0; i &amp;lt; 10; i++) { std::cout &amp;lt;&amp;lt; arr2[i] &amp;lt;&amp;lt; std::endl; } return 0; } 二维数组</description>
    </item>
    
    <item>
      <title>大小端判断</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%88%A4%E6%96%AD/</link>
      <pubDate>Wed, 19 Jul 2023 11:08:48 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%88%A4%E6%96%AD/</guid>
      <description>大小端判断
大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储期地址；
小端：较高的有效字节存放在较高的存储期地址，较低的有效字节存放在较低的存储期地址。
#include &amp;lt;iostream&amp;gt; union MyUnion { int a; char b; }; int func() { MyUnion union1; union1.a = 1; // 因小端存储，所以 union1.a == union1.b std::cout &amp;lt;&amp;lt; sizeof(union1) &amp;lt;&amp;lt; std::endl; return union1.a == union1.b; } int main(int argc, char* argv[]) { if (func()) { puts(&amp;#34;小端存储&amp;#34;); } else { puts(&amp;#34;大端存储&amp;#34;); } return 0; } </description>
    </item>
    
    <item>
      <title>动态、静态类型</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%8A%A8%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 15 Jul 2023 17:23:05 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%8A%A8%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</guid>
      <description>如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。
#include &amp;lt;iostream&amp;gt; struct Base { virtual ~Base() {} }; struct Derived : Base { }; int main(int argc, char* argv[]) { Derived derived; Base* ptr = &amp;amp;derived; puts(&amp;#34;----------------&amp;#34;); // (*ptr)的静态类型是B // (*ptr)的静态类型是D std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::is_same_v&amp;lt;std::remove_reference_t&amp;lt;decltype(*ptr)&amp;gt;, Base&amp;gt; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; (typeid(*ptr) == typeid(Base)) &amp;lt;&amp;lt; std::endl; // ---------------- // true // false } #include &amp;lt;iostream&amp;gt; #include &amp;lt;typeinfo&amp;gt; #define OUTPUT(f) std::cout &amp;lt;&amp;lt; #f &amp;lt;&amp;lt; &amp;#34;\t: &amp;#34; &amp;lt;&amp;lt; typeid(f).</description>
    </item>
    
    <item>
      <title>形参包解析</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%BD%A2%E5%8F%82%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 15 Jul 2023 16:49:48 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%BD%A2%E5%8F%82%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>形参包的解析可以有两种方式：
递归 折叠表达式 #include &amp;lt;iostream&amp;gt; template&amp;lt;int...args&amp;gt; constexpr int test1 = (args - ...); template&amp;lt;int...args&amp;gt; constexpr int test2 = (... - args); // 递归终止 void print1() {} template &amp;lt;typename T, typename...Types&amp;gt; void print1(const T&amp;amp; firstArg, const Types&amp;amp;...args) { std::cout &amp;lt;&amp;lt; firstArg &amp;lt;&amp;lt; std::endl; // print() first argument print1(args...); // call print() for remaining arguments } // 二元折叠表达式 template&amp;lt;typename...Args&amp;gt; void print2(Args&amp;amp;&amp;amp;...args) { (std::cout &amp;lt;&amp;lt; ... &amp;lt;&amp;lt; args) &amp;lt;&amp;lt; std::endl; } // 一元右折叠表达式+逗号表达式 template&amp;lt;typename.</description>
    </item>
    
    <item>
      <title>异常中new对象</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%BC%82%E5%B8%B8%E4%B8%ADnew%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 15 Jul 2023 16:10:41 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%BC%82%E5%B8%B8%E4%B8%ADnew%E5%AF%B9%E8%B1%A1/</guid>
      <description>MSVC下可通过编译，GCC报错。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;exception&amp;gt; struct MyException : std::exception { MyException(const char* s) : exception(s) { puts(&amp;#34;MyException()...&amp;#34;); } ~MyException() { puts(&amp;#34;~MyException()...&amp;#34;); } }; void f1() try { throw MyException(&amp;#34;MyException...&amp;#34;); } // 与其他临时对象不同，异常对象在初始化 catch 子句形参时被认为是左值， // 所以它可以用左值引用捕获、修改及重抛。 catch (std::exception&amp;amp; e) { std::cerr &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl; } void f2() try { throw new MyException(&amp;#34;new MyException...&amp;#34;); } catch (std::exception* e) { std::cerr &amp;lt;&amp;lt; e-&amp;gt;what() &amp;lt;&amp;lt; std::endl; delete e; } int main(int argc, char* argv[]) { f1(); puts(&amp;#34;----------------&amp;#34;); f2(); } </description>
    </item>
    
    <item>
      <title>伪析构函数</title>
      <link>https://jia-baos.github.io/basical-skills/%E4%BC%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 15 Jul 2023 12:21:10 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E4%BC%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>#include &amp;lt;iostream&amp;gt; template&amp;lt;typename T&amp;gt; concept is_destruct = requires(T t) { t.~T(); }; struct X { }; int main(int argc, char* argv[]) { // 拜伪析构函数调用所赐，所有标量类型都满足可析构 (Destructible) 的要求， // 而数组类型和引用类型则不满足。 std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; is_destruct&amp;lt;X&amp;gt; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; is_destruct&amp;lt;int&amp;gt; &amp;lt;&amp;lt; std::endl; using type = int; type a = 1; a.~type();	// 生存期结束 std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl;	// 生存期外，存储期内 } </description>
    </item>
    
    <item>
      <title>复制消除</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4/</link>
      <pubDate>Sat, 15 Jul 2023 11:14:08 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; struct X { X() { puts(&amp;#34;int&amp;#34;); } X(const int &amp;amp;) { puts(&amp;#34;const int&amp;amp;&amp;#34;); } X(int &amp;amp;&amp;amp;) { puts(&amp;#34;int&amp;amp;&amp;amp;&amp;#34;); } }; X f() { return X(); } int main(int argc, char *argv[]) { X x1 = 1; // int&amp;amp;&amp;amp; puts(&amp;#34;--------------&amp;#34;); X x2 = f(); // int } [1]复制消除</description>
    </item>
    
    <item>
      <title>运算符重载</title>
      <link>https://jia-baos.github.io/basical-skills/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 15 Jul 2023 10:39:36 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; struct X { int val_; X(int val) : val_{val} {} bool operator==(const X &amp;amp;x) const { return x.val_ == this-&amp;gt;val_; } }; struct Y { int val_; Y(int val) : val_{val} {} // 运算符重载推荐使用非成员函数 friend bool operator==(const Y &amp;amp;a, const Y &amp;amp;b) { return a.val_ == b.val_; } }; int main(int argc, char *argv[]) { X x1{1}; X x2{1}; Y y1{1}; Y y2{1}; x1 == x2; x2 == x1; x1 == 1; //1 == x1; // 在C++20可以保证被编译 y1 == y2; y2 == y1; y1 == 1; 1 == y1; } </description>
    </item>
    
    <item>
      <title>对象存储可变参数</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 15 Jul 2023 10:25:23 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; // std::invocable 检查类型能否以给定的实参类型调用 template&amp;lt;typename F, typename...Args&amp;gt; requires std::invocable&amp;lt;F, Args...&amp;gt; struct Input { using R = std::invoke_result_t&amp;lt;F, Args...&amp;gt;; F f_; // 可调用对象 std::tuple&amp;lt;Args...&amp;gt; value_; // 存储可变参数 Input(F f, Args...args) : f_(f), value_(args...) {} constexpr R operator()() const noexcept { // std::apply 推导以一组实参调用一个可调用对象的结果类型 return std::apply(f_, value_); } }; int main(int argc, char *argv[]) { // 传入可调用对象和形参包 Input input([](int a, float b) { std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl; }, 1, 2.</description>
    </item>
    
    <item>
      <title>函数声明</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 15 Jul 2023 10:05:33 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; void func(int n) { std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } using type = decltype(func); type F; // 函数声明 int main() { F(1); } void F(int) { std::cout &amp;lt;&amp;lt; &amp;#34;Defination of Function&amp;#34; &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>传递函数模板</title>
      <link>https://jia-baos.github.io/basical-skills/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sat, 15 Jul 2023 09:49:14 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>#include &amp;lt;bits/stdc++.h&amp;gt; #define BY_NAME(F) [](auto&amp;amp;&amp;amp;...args){return F(args...);} template&amp;lt;typename F, typename...Args&amp;gt; auto foo(F f, Args &amp;amp;&amp;amp;...args) { return f(std::forward&amp;lt;Args&amp;gt;(args)...); } int main() { const auto val1 = foo([](auto &amp;amp;&amp;amp;...args) { return std::min(args...); }, 1, 2); std::cout &amp;lt;&amp;lt; val1 &amp;lt;&amp;lt; std::endl; const auto val2 = foo(BY_NAME(std::min), 1, 2); std::cout &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>重载、重写、覆盖</title>
      <link>https://jia-baos.github.io/basical-skills/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96/</link>
      <pubDate>Fri, 14 Jul 2023 19:37:43 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96/</guid>
      <description>#include &amp;lt;iostream&amp;gt; class A { public: virtual void vfunc1() { puts(&amp;#34;A::vfunc1&amp;#34;); } virtual void vfunc2() { puts(&amp;#34;A::vfunc2&amp;#34;); } void func1() { puts(&amp;#34;A::func1&amp;#34;); } void func2() { puts(&amp;#34;A::func2&amp;#34;); } virtual void vfunc2(int val) { puts(&amp;#34;A::vfunc2 overload&amp;#34;); } void func2(int val) { puts(&amp;#34;A::func2 overload&amp;#34;); } private: int m_data1; int m_data2; }; class B :public A { public: virtual void vfunc1() { puts(&amp;#34;B::vfunc1&amp;#34;); } void func1() { puts(&amp;#34;B::func1&amp;#34;); } private: int m_data3; }; class C :public B { public: virtual void vfunc2() { puts(&amp;#34;C::vfunc2&amp;#34;); } void func2() { puts(&amp;#34;C::func2&amp;#34;); } private: int m_data1; int m_data4; }; int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; _MSVC_LANG &amp;lt;&amp;lt; std::endl; A a; B b; C c; puts(&amp;#34;-----------------&amp;#34;); a.</description>
    </item>
    
    <item>
      <title>STL仿函数</title>
      <link>https://jia-baos.github.io/basical-skills/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 12 Jul 2023 20:44:46 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</guid>
      <description>函数对象（也称 函子）是实现 operator() 的任何类型。 此运算符被称为 调用运算符 （有时称为 应用程序运算符）。 C++ 标准库主要使用函数对象作为容器和算法内的排序条件。
相对于直接函数调用，函数对象有两个优势。 第一个是函数对象可包含状态。 第二个是函数对象是一个类型，因此可用作模板参数。
#include &amp;lt;bits/stdc++.h&amp;gt; class Functor { public: int operator()(int a, int b) { return a &amp;lt; b; } }; int main() { std::cout &amp;lt;&amp;lt; __cplusplus &amp;lt;&amp;lt; std::endl; Functor f; int a = 5; int b = 7; std::cout &amp;lt;&amp;lt; f(a, b) &amp;lt;&amp;lt; std::endl; // 1 return 0; } 函数指针。
不足：无法利用函数指针指向模板函数。
#include &amp;lt;iostream&amp;gt; int cal(int val) { return val * val; } int main(int argc, char* argv[]) { // 函数指针定义方式 // 函数返回值类型 (* 指针变量名) (函数参数列表) int (*ptr_func)(int) = nullptr; ptr_func = cal; int val1 = cal(5); // 通过函数调用 int val2 = (*ptr_func)(5); // 通过指针调用，推荐 int val3 = ptr_func(5); // 不推荐 std::cout &amp;lt;&amp;lt; &amp;#34;val1 &amp;#34; &amp;lt;&amp;lt; val1 &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;val2 &amp;#34; &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;val3 &amp;#34; &amp;lt;&amp;lt; val3 &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>模块</title>
      <link>https://jia-baos.github.io/basical-skills/%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 12 Jul 2023 17:16:44 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E6%A8%A1%E5%9D%97/</guid>
      <description>// Module.ixx module; import &amp;lt;concepts&amp;gt;; export module test; namespace JB { export template&amp;lt;typename T&amp;gt; requires std::is_integral_v&amp;lt;T&amp;gt; T add(const T&amp;amp; t) { return t + 1; } } // main.cpp #include &amp;lt;iostream&amp;gt; import test; int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; JB::add(1) &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>完美转发</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Wed, 12 Jul 2023 08:23:07 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>std::forward被称为完美转发，它的作用是保持原来的值属性不变。
#include &amp;lt;bits/stdc++.h&amp;gt; template&amp;lt;typename T&amp;gt; void print(T &amp;amp; t){ std::cout &amp;lt;&amp;lt; &amp;#34;left value&amp;#34; &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T&amp;gt; void print(T &amp;amp;&amp;amp; t){ std::cout &amp;lt;&amp;lt; &amp;#34;right value&amp;#34; &amp;lt;&amp;lt; std::endl; } template&amp;lt;typename T&amp;gt; void testForward(T &amp;amp;&amp;amp; v){ print(v); print(std::forward&amp;lt;T&amp;gt;(v)); print(std::move(v)); } int main() { std::cout &amp;lt;&amp;lt; __cplusplus &amp;lt;&amp;lt; std::endl; testForward(1); /* * left value * right value * right value */ int x = 1; testForward(x); /* * left value * left value * right value */ return 0; } #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>概念、约束</title>
      <link>https://jia-baos.github.io/basical-skills/%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Tue, 11 Jul 2023 22:42:52 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;concepts&amp;gt; template&amp;lt;typename T&amp;gt; concept is_integral = std::is_integral_v&amp;lt;T&amp;gt;; // requires 子句，不是 requires 表达式 template&amp;lt;typename T&amp;gt; requires is_integral&amp;lt;T&amp;gt; T add0(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;用require关键字定义一个概念或约束，requires子句&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } // 临时约束，注意关键字用了两次 template&amp;lt;typename T&amp;gt; requires requires (T t) { std::is_integral_v&amp;lt;T&amp;gt;; } T add1(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;用require关键字定义一个概念或约束，requires表达式，临时约束&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } template&amp;lt;typename T&amp;gt; T add2(const T&amp;amp; t) requires is_integral&amp;lt;T&amp;gt; { std::cout &amp;lt;&amp;lt; &amp;#34;在函数签名中使用require关键字&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } template&amp;lt;is_integral T&amp;gt; T add3(const T&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;在模板声明中使用概念&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } auto add4(const is_integral auto&amp;amp; t) { std::cout &amp;lt;&amp;lt; &amp;#34;在参数列表中使用概念&amp;#34; &amp;lt;&amp;lt; std::endl; return t + 1; } // 经由返回类型启用 template&amp;lt;typename T&amp;gt; typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type add5(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由返回类型启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } // 经由非类型模板形参启用 template&amp;lt;typename T, std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type = 0&amp;gt; T add6(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由非类型模板形参启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } // 经由类型模板形参启用 template&amp;lt;typename T, typename = typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type&amp;gt; T add7(const T&amp;amp; arg) { std::cout &amp;lt;&amp;lt; &amp;#34;经由类型模板形参启用&amp;#34; &amp;lt;&amp;lt; std::endl; return arg + 1; } int main(int argc, char* argv[]) { std::cout &amp;lt;&amp;lt; add0(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add1(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add2(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add3(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add4(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add5(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add6(1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add7(1) &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>Traits特性</title>
      <link>https://jia-baos.github.io/basical-skills/traits%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 11 Jul 2023 15:15:37 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/traits%E7%89%B9%E6%80%A7/</guid>
      <description>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”. - Bjarne Stroustrup
模板的全特化、偏特化。
#include &amp;lt;bits/stdc++.h&amp;gt; // 模板一般化设计 /* * 模板全特化和偏特化设计版本存在时， * 优点调用 */ template &amp;lt;typename T&amp;gt; struct MyPrint { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板一般化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 模板全特化设计 template &amp;lt;&amp;gt; struct MyPrint&amp;lt;float&amp;gt; { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板全特化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 模板偏特化设计 /* *模板特化时，可以只指定一部分而非所有模板参数， *或者是参数的一部分而非全部特性，这叫做模板的偏特化。 *一个类模板的偏特化本身是一个模板， *使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。 */ template &amp;lt;typename T&amp;gt; struct MyPrint&amp;lt;T *&amp;gt; { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;模板偏特化设计&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main(int argc, char *argv[]) { MyPrint&amp;lt;int&amp;gt; a; MyPrint&amp;lt;float&amp;gt; b; MyPrint&amp;lt;float *&amp;gt; c; a.</description>
    </item>
    
    <item>
      <title>左值、右值</title>
      <link>https://jia-baos.github.io/basical-skills/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</link>
      <pubDate>Mon, 10 Jul 2023 10:46:51 +0800</pubDate>
      
      <guid>https://jia-baos.github.io/basical-skills/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</guid>
      <description>值类别 每个 C++ 表达式（带有操作数的操作符、字面量、变量名等）可按照两种独立的特性加以辨别：类型和值类别 (value category)。每个表达式都具有某种非引用类型，且每个表达式只属于三种基本值类别中的一种：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)。
泛左值 (glvalue)（“泛化 (generalized)”的左值）是一个表达式，其值可确定某个对象或函数的标识； 纯右值 (prvalue)（“纯 (pure)”的右值）是求值符合下列之一的表达式： 计算某个运算符的操作数的值（这种纯右值没有结果对象） 初始化某个对象（称这种纯右值有一个结果对象）。结果对象可以是变量，由 new 表达式创建的对象，由临时量实质化创建的临时对象，或者前述三类对象的成员。注意非 void 的弃值表达式有结果对象（即被实质化的临时量）。并且在作为 decltype 的操作数以外的情况下，每个类类型或数组类型的纯右值都有结果对象； 亡值 (xvalue)（“将亡 (expiring)”的值）是代表它的资源能够被重新使用的对象或位域的泛左值； 左值 (lvalue)（如此称呼的历史原因是，左值可以在赋值表达式的左边出现）是非亡值的泛左值； 右值 (rvalue)（如此称呼的历史原因是，右值可以在赋值表达式的右边出现）是纯右值或者亡值。 基本类别 左值 下列表达式是左值表达式：
变量、函数、模板形参对象 (C++20 起)或数据成员的名字，不论类型，例如 std::cin 或 std::endl。即使变量的类型是右值引用，由它的名字构成的表达式仍是左值表达式； 返回类型是左值引用的函数调用或重载运算符表达式，例如 std::getline(std::cin, str)、std::cout &amp;lt;&amp;lt; 1、str1 = str2 或 ++it； a = b，a += b，a %= b，以及所有其他内建的赋值及复合赋值表达式； ++a 和 --a，内建的前置自增与前置自减表达式； *p，内建的间接寻址表达式； a[n] 和 n[a]，内建的下标表达式，当 a[n] 中的一个操作数是数组左值时 (C++11 起)； a.m，对象成员表达式，除了 m 是成员枚举项或非静态成员函数，或者 a 是右值而 m 是对象类型的非静态数据成员的情况； p-&amp;gt;m，内建的指针成员表达式，除了 m 是成员枚举项或非静态成员函数的情况； a.</description>
    </item>
    
  </channel>
</rss>
